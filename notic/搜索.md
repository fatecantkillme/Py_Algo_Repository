# DFS

在搜索问题中，DFS 主要用于 **遍历所有可能的解空间**

**通用框架 (递归实现):**

```
DFS(当前状态):
  判断当前状态是否为目标状态:
    如果是目标状态，记录解或返回 true (成功)
  判断当前状态是否无效或需要剪枝:
    如果是无效状态，返回 false (失败)
  遍历当前状态可以扩展出的所有子状态:
    for each 子状态:
      DFS(子状态)  // 递归搜索子状态
```

**框架解释：**

- 当前状态：

    描述搜索过程中的当前情况。状态的具体表示方式取决于具体问题，例如：

  - **序列问题：**  当前已经构造的序列部分。
  - **图问题：**  当前已经访问的节点集合，或者当前的路径。
  - **排列组合问题：**  当前已经选择的元素集合。

- **目标状态：**  搜索的目标，即满足题目要求的解。

- **无效状态/剪枝：**  在搜索过程中，如果发现当前状态不可能到达目标状态，或者已经不符合题目约束，就可以 **剪枝**，提前结束当前分支的搜索，避免无效的探索，提高效率。

- 子状态：

    从当前状态可以扩展出的下一步状态。如何扩展子状态也取决于具体问题，例如：

  - **序列问题：**  在序列末尾添加一个数字。
  - **图问题：**  访问当前节点的邻接节点。
  - **排列组合问题：**  选择下一个元素加入集合。

**关键要素：**

- **状态表示：**  如何有效地表示搜索过程中的状态。
- **状态转移 (扩展子状态)：**  如何从当前状态转移到下一个状态。
- **终止条件 (目标状态)：**  如何判断是否找到了目标解。
- **剪枝条件 (无效状态)：**  如何有效地剪枝，减少搜索空间。

#### 3.1. 全排列问题

**题目描述 (简化)：**  给定一个数字 `n`，输出 `1` 到 `n` 的所有全排列。

**分析：**

- **状态表示：**  当前已经生成的部分排列。可以用一个数组 `p` 来存储，`p[1...k]` 表示已经确定的前 `k` 个位置的数字。
- **目标状态：**  当 `k > n` 时，表示已经生成了一个完整的排列，即目标状态。
- **子状态：**  在确定第 `k` 个位置的数字时，可以从 `1` 到 `n` 中选择一个 **尚未被使用** 的数字。
- **剪枝：**  这里没有明显的剪枝，因为全排列问题需要枚举所有可能性。