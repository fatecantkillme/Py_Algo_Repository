## 核心思想

> - 把原问题分解为【若干重叠的子问题】，每个子问题的求解都是一个【过程】
> - 求解子问题的过程采用【自顶向下的记忆化搜索】或者【自底向上的递推方法】

### 简单例子

**斐波那契数列**：数列由 f(0)=1,f(1)=2*f*(0)=1,*f*(1)=2 开始，后面的每一项数字都是前面两项数字的和

**如果使用传统方法求解某斐波那契数的值那么注定在计算过程中会有重叠的子问题，所以我们使用自底向上的递推方法使用表格储存了已经解决问题的答案避免子问题重叠**

```python
def fip(self,n):
	if n == 0:
        return 0
    if n ==1:
        return 1
    dp=[0 for _ in range(n+1)]
    dp[1]=1
    for i in range(2,n+1):
        dp[i]=dp[i-2]+dp[i-1]
    return dp[n]
```

## DP特征

### 最优子结构

问题最优解包含子问题最优解

### 重叠子问题

将问题拆分过程中，会有大量的子问题是重叠的

### 无后效性

一旦某结果被确定就不会被后面的结果影响

## DP基本思路

1. 划分阶段：将原问题分解为若干个相互联系的【阶段】
2. 定义【状态】，一个状态对应一个或多个子问题，某个状态下的值就是这个状态对应的子问题的解
3. 状态转移：根据上一阶段的状态推导出下一阶段的状态然后推导出状态间的相互转移方程【状态转移方程】
4. 初始条件和边界条件

## 记忆化搜索

**使用缓存来保存已经求子问题的结果**

当调用求解子问题时先判断此子问题是否已经被求结过了

### 记忆化搜索与递推区别